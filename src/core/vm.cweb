@* ByVM Core | Binary Virtual Machine with C FFI Only

This is a simplified version of ByVM with C-only FFI support.

@c
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
include <string.h>
#include "../symbolic/symbolic.h"

#define MEMORY_SIZE 256
#define NUM_REGISTERS 4
#define STACK_START 0xF0  /* Stack grows downward from top of memory */

#define LOAD      0x01
#define STORE     0x02
#define ADD       0x03
#define JUMP      0x04
#define HALT      0x05
#define PUSH      0x06
#define POP       0x07
#define CALL_FFI  0xF0  /* Opcode for C FFI */

#define SYMBOL_DEFINE  0xE0
#define SYMBOL_APPLY   0xE1
#define META_REFLECT   0xE2

uint8_t memory[MEMORY_SIZE];
uint8_t registers[NUM_REGISTERS];
uint8_t pc = 0;  // Program Counter
uint8_t sp = STACK_START;  // Stack Pointer
uint8_t running = 1;

void call_ffi(uint8_t func_id) {
    switch (func_id) {
        case 0x01:
            printf("[C FFI] Hello from C function!\n");
            break;
        case 0x02:
            printf("[C FFI] Value in Register 0: %d\n", registers[0]);
            break;
        default:
            printf("[C FFI] Unknown external function: %d\n", func_id);
            break;
    }
}

void load_program(uint8_t *program, size_t size) {
    for (size_t i = 0; i < size && i < MEMORY_SIZE; ++i) {
        memory[i] = program[i];
    }
}

void execute() {
    while (running) {
        uint8_t opcode = memory[pc++];
        switch (opcode) {
            case LOAD: {
                uint8_t reg = memory[pc++];
                uint8_t value = memory[pc++];
                registers[reg] = value;
                break;
            }
            case STORE: {
                uint8_t reg = memory[pc++];
                uint8_t addr = memory[pc++];
                memory[addr] = registers[reg];
                break;
            }
            case ADD: {
                uint8_t reg1 = memory[pc++];
                uint8_t reg2 = memory[pc++];
                uint8_t dest = memory[pc++];
                registers[dest] = registers[reg1] + registers[reg2];
                break;
            }
            case JUMP: {
                uint8_t addr = memory[pc++];
                pc = addr;
                break;
            }
            case PUSH: {
                uint8_t reg = memory[pc++];
                if (sp == 0) {
                    printf("Stack overflow!\n");
                    running = 0;
                    break;
                }
                memory[--sp] = registers[reg];
                break;
            }
            case POP: {
                uint8_t reg = memory[pc++];
                if (sp >= STACK_START) {
                    printf("Stack underflow!\n");
                    running = 0;
                    break;
                }
                registers[reg] = memory[sp++];
                break;
            }
            case SYMBOL_DEFINE: {
                uint8_t id = memory[pc++];
                uint8_t reg = memory[pc++];
                symbol_define(id, registers[reg]);
                break;
            }
            case SYMBOL_APPLY: {
                uint8_t id = memory[pc++];
                symbol_apply(id);
                break;
            }
            case META_REFLECT: {
                meta_reflect();
                break;
            }
            case CALL_FFI: {
                uint8_t func_id = memory[pc++];
                call_ffi(func_id);
                break;
            }
            case HALT: {
                running = 0;
                break;
            }

            default:
                printf("Unknown opcode: %02X\n", opcode);
                running = 0;
                break;
        }  
    }
}

int main(int argc, char *argv[]) {
    symbolic_init();

    if (argc < 2) {
        printf("Usage: %s <program file>\n", argv[0]);
        return 1;
    }

    FILE *fp = fopen(argv[1], "rb");
    if (!fp) {
        perror("Error opening file");
        return 1;
    }

    uint8_t buffer[MEMORY_SIZE];
    size_t size = fread(buffer, 1, MEMORY_SIZE, fp);
    fclose(fp);

    printf("[ByVM] Loaded %zu bytes from %s\n", size, argv[1]);
    load_program(buffer, size);
    execute();

    return 0;
}
